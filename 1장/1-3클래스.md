# 1.3 클래스

**학습 목표**

-   클래스의 개념에 대해 알 수 있다
-   클래스의 작동 원리를 알 수 있다
-   클래스에서 프로퍼티와 메서드를 어떻게 선언하는지 알 수 있다
-   클래스에서 접근제한자(private, public)를 어떻게 사용하는지 알 수 있다
-   클래스와 프로토타입의 상관관계에 대해 알 수 있다
-   상속에 대해 알 수 있다
-   리액트 클래스 컴포넌트에 대한 이해도를 높일 수 있다

### 클래스의 개념에 대해 알 수 있다

-   자바스크립트의 클래스란 특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념
-   즉, 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이 바로 클래스
-   자바스크립트의 클래스는 함수의 한 종류다

### 클래스의 작동 원리를 알 수 있다

-   클래스는 ES6에서 나온 개념으로, ES6 이전에는 프로토타입을 활용해 클래스의 작동 방식과 동일하게 구현했었다. 반대로 말하면, 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것이라고 볼 수 있다.

```jsx
// sample code
class Car {
    constructor(name) {
        this.name = name;
    }

    honk() {
        console.log(`${this.name}이 경적을 울립니다!`);
    }

    static hello() {
        console.log("저는 자동차입니다");
    }

    set age(value) {
        this.carAge = value;
    }

    get age() {
        return this.carAge;
    }
}

// ES5 환경 지원을 위해 위 코드를 prototype 형태로 트랜스파일링
var Car = (function () {
    function Car(name) {
        this.name = name;
    }

    // 프로토타입 메서드. 실제로 프로토타입에 할당해야 프로토타입 메서드로 작동한다.
    Car.prototype.honk = function () {
        console.log(`${this.name}이 경적을 울립니다!`);
    };

    // 정적 메서드. 인스턴스 생성 없이 바로 호출 가능하므로 직접 할당했다.
    Car.hello = function () {
        console.log("저는 자동차입니다");
    };

    // Car 객체에 속성을 직접 정의했다
    Object.defineProperty(Car, "age", {
        // get과 set은 각각 접근자, 설정자로 사용할 수 있는 예약어다.
        // getter
        get: function () {
            return this.carAge;
        },
        // setter
        set: function (value) {
            this.carAge = value;
        },
    });
    return Car;
})();
```

### 클래스에서 프로퍼티와 메서드를 어떻게 선언하는지 알 수 있다

-   constructor 생성자
    -   객체를 생성하는 데 사용하는 특수한 메서드
    -   단 하나만 존재할 수 있음 (생략 가능)
-   프로퍼티
    -   클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
    -   기본적으로 인스턴스 생성 시 constructor 내부에는 빈 객체가 할당돼 있는데 바로 이 빈 객체에 프로퍼티의 키와 값을 넣어서 활용할 수 있게 도와준다.
-   getter와 setter
    -   getter 란 클래스에서 무언가 값을 가져올 때 사용한다
    -   getter를 사용하기 위해서는 get을 앞에 붙여야 하고, 뒤이어서 getter의 이름을 선언해야 한다
    -   setter 란 클래스 필드에 값을 할당할 때 사용한다.
    -   마찬가지로 set 이라는 키워드를 먼저 선언하고, 그 뒤를 이어서 이름을 붙이면 된다
-   인스턴스 메서드
    -   클래스 내부에서 선언한 메서드
-   정적 메서드
    -   클래스의 인스턴스가 아닌 클래스 자신의 이름으로 호출할 수 있는 메서드
    -   정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌, 클래스 자신을 가리키기 때문에 다른 메서드에서 일반적으로 사용하는 this를 사용할 수 없다
    -   생성하지 않아도 접근할 수 있는 특성때문에 여러 곳에서 재사용이 가능하다는 장점이 있다
    -   이 때문에 전역에서 사용하는 유틸 함수를 정적 메서드로 많이 활용하는 편이다

### 클래스에서 접근제한자(private, public)를 어떻게 사용하는지 알 수 있다

-   다른 언어처럼 접근제한자가 완벽하게 지원되지 않는다
-   ES2019부터 #을 붙여 private을 선언하는 방법이 추가됐다
-   타입스크립트를 활용하면 private, protected, public 을 사용할 수 있다
-   자바스크립트는 기본적으로 모든 프로퍼티가 public 이다

### 클래스와 프로토타입의 상관관계에 대해 알 수 있다

-   인스턴스 메서드는 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 한다
-   직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것을 바로 프로토타입 체이닝이라고 한다
-   모든 객체는 프로토타입을 가지고 있는데, 특정 속성을 찾을 때 자기 자신부터 시작해서 이 프로토타입을 타고 최상위 객체인 Object까지 훑는다.
-   결론적으로 이 프로토타입과 프로토타입 체이닝이라는 특성 덕분에 인스턴스는 클래스에서 선언한 hello() 메서드를 호출할 수 있고, 이 메서드 내부에서 this도 접근해 사용할 수 있게 된다.

### 상속에 대해 알 수 있다

-   extends 를 통해 상속할 수 있다
-   상속은 기존 클래스를 상속받아 자식 클래스에서 이 상속받은 클래스를 기반으로 확장하는 개념이다

### 리액트 클래스 컴포넌트에 대한 이해도를 높일 수 있다

-   리액트 클래스형 컴포넌트 생명주기 메서드인 static getDerivedStateFromProps(props, state)에서는 this.state 에 접근할 수 없다
-   리액트에서 클래스형 컴포넌트를 만들기 위해 extends React.Component 또는 React.PureComponent 를 선언한다
